{
  "author": {
    "name": "Thomas Burleson"
  },
  "email": "ThomasBurleson@gmail.com",
  "url": "http://www.gridlinked.info",
  "name": "jasmine-as-promised",
  "description": "Extensions to Jasmine unit testing to transparently support Promises in async testing scenarios",
  "keywords": [
    "jasmine",
    "promises",
    "unit testing",
    "async"
  ],
  "main": "./src/jasmine-as-promised.js",
  "homepage": "https://github.com/Mindspace/jasmine-as-promised",
  "bugs": {
    "email": "ThomasBurleson@gmail.com"
  },
  "license": "MIT",
  "version": "0.0.8",
  "repository": {
    "type": "git",
    "url": "https://github.com/Mindspace/jasmine-as-promised"
  },
  "devDependencies": {
    "jasmine": "~1.3.1"
  },
  "readme": "# Promise-Returning Tests for Jasmine\n\nSo you really like [Jasmine](https://github.com/pivotal/jasmine). But you also really like [promises](). And you'd like to see \nsupport in [Jasmine](https://github.com/pivotal/jasmine) for the promise-returning test style; similar to the great work by [Domenic Denicola](https://github.com/domenic) for the [Mocha as Promised](https://github.com/domenic/mocha-as-promised) and others.\n\nThis library provides an extension of the Jasmine `Spec::runs()` to support Promises \nand will auto-magically wait for the promise to resolve or reject before continuing with subsequent unit tests.\n\nBest of all... it supports **AngularJS** and will signficantly reduce the size of your test code (see bottom).\n\n## The Old Way\n\nUntil now you've been making do with manual solutions that explicity use `runs()` and `waitsFor()` \nto force the test runner to pause the tests while waiting for the async response. \n\nHere is a sample of code constructed in the tradition, *old way*. For purposes of code samples, let's consider API tests where the `authors.validate()` \nis asynchronous and returns a promise instance:\n\n```js\nit( \"should respond successfully for valid authors\", function () {\n\tvar ready  = false,\n\t\tresult;\n\t\t\n\t\truns( function() \n\t\t{\n\t\t\tauthors\n\t\t\t    .validate(\"Domenic Denicola\")\n\t\t\t    .then(\n\t\t\t    \tfunction onResponse( data )\n\t\t\t    \t{\n\t\t\t    \t\tresult = data;\n\t\t\t    \t\tready  = true;\t\t// continue test runner\n\t\t\t    \t},\n\t\t\t    \tfunction onError( fault )\n\t\t\t    \t{\n\t\t\t    \t\tready  = true;\t\t// continue test runner\n\t\t\t    \t}\n\t\t\t    );\n\t\t});\n\n\t\t// Pause test runner until timeout or yourAsyncCall() responds\t\t\n\t\twaitsFor( function() \n\t\t{\n\t\t\treturn result;\n\t\t});\n\t\t\n\t\t\n\t\t// Run the code that checks the expectations…\n\t\t\n\t\truns( function() \n\t\t{\n\t\t\texpect( result.valid ).toBeEqual( 1 );\n\t\t\texpect( result.level ).toBeEqual( \"awesome\" );\n\t\t});\t    \n});\n```\n\nDevelopers will immediately note that this traditional approach is verbose and error-prone when developers are need to create many tests for their async APIs.\n\n## The New, Better Solution\n\nWith Jasmine-As-Promised and APIs that return promises, consider the code tersity and simplicity that can be realized\nwhen your unit tests return Promises:\n\n```js\nit( \"should be respond for valid authors\", function () \n{\n\truns( function() \n\t{    \t\n\t\treturn authenticator\n\t\t\t.validate(\"Domenic Denicola\" )\n\t\t\t.then( function (result) \n\t\t\t{\n\t\t\t\texpect( result.valid ).toBeEqual( 1 );\n\t\t\t\texpect( result.level ).toBeEqual( \"awesome\" );\n\t\t\t});\n\t});\n});\n```\n\nYou could even separate your `expect()` calls if wanted. Instead of nesting your expectations inside\nthe promise handler, consider another supported approach:\n\n```js\nit( \"should respond successfully for valid authors\", function () \n{\n\truns( \n\t\tfunction() \n\t\t{    \t\n\t\t\treturn authenticator.validate(\"Domenic Denicola\" );\n\t\t},\n\t\tfunction checkExpectations( result ) \n\t\t{\n\t\t\texpect( result.valid ).toBeEqual( 1 );\n\t\t\texpect( result.level ).toBeEqual( \"awesome\" );\n\t\t}\n\t);\n});\n```\n\nWith this *new* approach developers no longer need to worry about `waitsFor()`, latch methods, etc. With Jasmine as Promised, you have a much two (2) much nicer, easily applied options available! \n\n## How to Use\n\nOnce you install and set up **Jasmine-as-Promised**, you now have a second way of creating asynchronous tests, besides Jasmine's\nusual `runs(); waitsFor(); runs();` style. Just return a promise. When the promise is resolved the test expectations are checked and if it is rejected the test\nfails, with the rejection reason as the error. Nice, huh?\n\nJasmine as Promised works with all Jasmine interfaces: BDD, TDD, QUnit, whatever. It hooks in at such a low level, the\ninterfaces don't even get involved.\n\n\n## This is NOT Jasmine-Node\n\n[Jasmine-Node](https://github.com/mhevery/jasmine-node) is a project that integrates the Jasmine Spec framework with NodeJS. \n\njasmine-node includes an alternate syntax for writing asynchronous tests. Accepting a done callback in the specification will trigger jasmine-node to run the test asynchronously waiting until the done() callback is called.\n\n```js\nvar request = require('request');\n\nit(\"should respond with hello world\", function(done) {\n  request(\"http://localhost:3000/hello\", function(error, response, body){\n    expect(body).toEqual(\"hello world\");\n    done();\n  });\n});\n```\n\nNotice that this `Jasmine-as-Promised` library does **not** use a done callback function argument in the `it( )` call. But developers can still use Jasmine-As-Promised with   Jasmine-Node; see the usage notes below for use with Node.\n\n## Installation and Usage\n\n### Node\n\nDo an `npm install jasmine-as-promised --save-dev` to get up and running. Then:\n\n```js\nrequire(\"jasmine-as-promised\")();\n```\n\nYou can of course put this code in a common test fixture file; for an example, see\n[the Jasmine as Promised tests]().\n\n### AMD\n\n**Jasmine-as-Promised** supports being used as an [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) module, registering itself anonymously. So, assuming you have\nconfigured your loader to map the Jasmine and Jasmine as Promised files to the respective module IDs `\"jasmine\"` and\n`\"jasmine-as-promised\"`, you can use them as follows:\n\n```js\ndefine(function (require, exports, module) {\n    var jasmine = require(\"jasmine\");\n    var jasmineAsPromised = require(\"jasmine-as-promised\");\n\n    jasmineAsPromised(jasmine);\n});\n```\n\n### `<script>` tag\n\nIf you include **Jasmine-as-Promised** directly with a `<script>` tag, after the one for Jasmine itself, then it will\nautomatically plug in to Jasmine and be ready for use:\n\n```html\n\n<script src=\"jasmine\"></script>\n<script src=\"jasmine-as-promised.js\"></script>\n\n```\n\n### Node, the Advanced Version\n\nThe `require(\"jasmine-as-promised\")()` above tries to detect which instance of Jasmine is being used automatically. This\nway, **Jasmine-as-Promised** can plug into either the local Jasmine instance installed into your project, or into the global\nJasmine instance if you're running your tests using the globally-installed command-line runner.\n\nIn some cases, if you're doing something weird, this can fall down. In these cases, you can pass the Jasmine instance into\ninto the **Jasmine-as-Promised** function. For example, if you somehow had your Jasmine module as a property of the `foo` module,\ninstead of it being found in the usual npm directory structures, you would do\n\n```js\nrequire(\"jasmine-as-promised\")(require(\"foo\").MyJasmine);\n```\n\n### Bower, the Package Manager\n\nNow you can use `Bower` (the package manager for the web) to get the most recent released version of the library installed in your project-relative `bower_components` directory.\n\n```js\nbower install jasmine-as-promised\n```\n\nAnd Bower will also auto-install the `Jasmine` library for you; as part of this library install.\n\n\n## How Does This Work!?\n\nWhile this approach using the interceptor or *head hook* approach, it should be note that this is hack... albeit a reasonable one.\nNote that **Jasmine-as-Promised** just overrides the `window.runs` method (published as part of Jasmine core); check the source for more details.\n\n## Using with AngularJS\n\nWhen using AngularJS with Jasmine Specs (and Jasmine-as-Promised ), developers have two (2) types of test scenarios:\n\n*  Testing with [angular-mocks](https://github.com/angular/bower-angular-mocks) to use mock $http and mock $timeout(s).\n*  Testing with [angular-spec]() to use Jasmine tests with LIVE $http (real XHR) calls.\n\nDevelopers should study the test **Specs** prepared within [test_withAngular.html](https://github.com/Mindspace/jasmine-as-promised/blob/master/test/test_withAngular.html). \nThat file shows you how:\n\n*  script libraries should be loaded (for tests)\n*  Jasmine should be started\n*  angular services can be constructed with mock APIs\n*  Spec(s) can be implemented using `inject( )` and `runs( )`\n*  Angular Promise-based services can be easily tested.\n\n\n### Using RequireJS\n\nDevelopers should note that these do NOT show how RequireJS can also be used… that is out-of-scope for this project. \nIf you really need to know how to use RequireJS with your tests and Karma, contact me or come and see me at the 2014 NG-Conference\n",
  "readmeFilename": "README.md",
  "_id": "jasmine-as-promised@0.0.8",
  "dist": {
    "shasum": "7d43ac7297c3eaaaab45c528f998a1906ac829a1"
  },
  "_from": "jasmine-as-promised@0.0.8",
  "_resolved": "https://registry.npmjs.org/jasmine-as-promised/-/jasmine-as-promised-0.0.8.tgz"
}
